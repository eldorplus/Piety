#!/usr/bin/env python
"""
piety_line.twisted - Session + Job + CommandLine + pysh, ed, edd + Twisted scheduler

Uses Twisted as the non-blocking scheduler.
Much like piety script, except use commandline.CommandLine not command.Command

Use directions in piety script docstring, in particular use edc(...)
to start line editor and edd(...) for display editor.

BUT this only provides rudimentary inline editing: backspace and ^U
(kill whole line), no other control or arrow keys, no history.
Also, ^D does not exit from editors or shell - it just hangs.
"""
import sys # used in sys.stdout.flush in Console both methods, below

import piety # used in Console lineReceived method, below

# Piety Writer tasks in writer_tasks module don't appear explicitly here - 
# they are referenced by the piety.schedule data structure used by piety.run
import writer_tasks

# Likewise, console jobs and session are referenced in console_line_tasks.jobs,
# and the session is also referenced in piety.schedule
# Must import identifiers used below and in pysh shell
# It seems pysh shell command line sees same scope as code in this module
from console_line_tasks import console, pysh, jobs, edc, edd

# Twisted, use this instead of the piety scheduler

from twisted.internet import stdio, reactor
from twisted.protocols import basic

class Console(basic.LineReceiver):
    'Twisted-style handler for input from stdin'

    from os import linesep as delimiter

    # Must provide methods with these names (override basic.Linereceiver)
    # FIXME - is this comment true?

    def connectionMade(self):
        jobs.pysh() # start the first Piety job, begin prompting
        sys.stdout.flush() # show initial prompt

    def lineReceived(self, line):
        console.handler(line) #  call Piety Session
        sys.stdout.flush() # show prompt
        piety.ievent[sys.stdin] += 1 # count events
        # interval = adjust_interval(t0, interval) # I think we don't need this
        if pysh.pexit:
            reactor.stop()

class Timeout(object):
    'Twisted-style timeout handler'

    def __init__(self):
        self.period = 1 # second, same as embedded script.
        self.nevents = 10 # same as embedded script

    def handler(self):
        if False and piety.ievent[piety.timeout] == self.nevents:
            # Now we use pysh.exit to stop, in Console lineReceived handler
            reactor.stop()
        else:
            # handle scheduled timeout events
            if piety.timeout in piety.schedule:
                for t in piety.schedule[piety.timeout]:
                    if t.enabled():
                        t.handler()
            else:
                pass # if no timeout handler, just continue
            # count events and schedule next timeout
            piety.ievent[piety.timeout] += 1
            interval = self.period # if we got here, full interval has elapsed
            reactor.callLater(interval, self.handler)

def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    in a non-blocking event loop scheduled by Twisted
    """
    reactor.callWhenRunning(Timeout().handler)  # should this go in main() - ?
    stdio.StandardIO(Console())
    reactor.run()

if __name__ == '__main__':
    main()
