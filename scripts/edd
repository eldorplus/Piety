#!/usr/bin/env python
"""
Run a Piety session including the ed line editor and edd display editor

  $ edd
>> piety.tasks()
... pysht, edd ...
>> edd()
... display appears ...
e README.md
1
q
>> ... any python statements ...
>> ed()
... now ed sees the buffers and other editor state left by edd ...
q
>> ^D
 $

This script shows how to ensure that console focus is switched between
the  console tasks: the shell pysht and the editors ed and edd, by using
console.Command.

This script shows how the ed line editor and the edd display editor
use the same buffers, cursor positions, and other editor state.  Both
ed and edd store and update editor state in the ed0 module.

"""

import sys

import console
import piety
import pysht

# use 'import foo as foo_m' so we can use foo as command name
import writer # not a console command - writers run in the background
import ed
import edd

class Prefix(object): pass  # use object names as disambigating prefixes

task = Prefix() # piety.Task objects
vt = Prefix() # console.Console objects
rc = Prefix() # console.Command objects 

# pysht

# vt.pysht is the console object whose command is the pysht shell
vt.pysht = console.Console(prompt='>> ', command=pysht.mk_shell(), exiter=piety.exit)

# task.pysht is the task running the vt.pysht console object
task.pysht= piety.Task(name='pysht', handler=vt.pysht.getchar, event=piety.sys.stdin,
                    enabled=(lambda: console.focus == vt.pysht))

# rc.pysht is the callable to invoke to run the pysht shell in the real console
rc.pysht = console.Command(vt.pysht, vt.pysht.restart, piety.none, piety.none, None)

# edd

vt.edd = console.Console(prompt='', command=edd.cmd, exiter=piety.exit)
task.edd = piety.Task(name='edd', handler=vt.edd.getchar, event=piety.sys.stdin,
                    enabled=(lambda: console.focus == vt.edd))
rc.edd = console.Command(vt.edd, edd.init_display, ed.q, edd.restore_display,
                      vt.pysht)
# ed

vt.ed = console.Console(prompt='', command=ed.cmd, exiter=piety.exit)
task.ed = piety.Task(name='ed', handler=vt.ed.getchar, event=piety.sys.stdin,
                    enabled=(lambda: console.focus == vt.ed))
rc.ed = console.Command(vt.ed, none, ed.q, none, vt.pysht)

# writers

# use this for t1.guard
def alternate():
    'Returns True on every other timeout event'
    return bool(piety.ievent[piety.timeout]%2)

# w0 writer task assigned enabled=piety.false so they don't start running
wr0, wr1 = writer.Writer(fname='w0.txt'), writer.Writer(fname='w1.txt')
task.w0 = piety.Task(name='w0',handler=wr0.write,event=piety.timeout,enabled=piety.false)
task.w1 = piety.Task(name='w1',handler=wr1.write,event=piety.timeout,enabled=alternate)

def run():
    'Assign focus to pysht shell, print shell prompt, (re)start scheduler.'
    rc.pysht()
    piety.done = False # reset, might be resuming after piety.exit() 
    piety.run(nevents=0) # loop forever, don't return

if __name__ == '__main__':
    run()
