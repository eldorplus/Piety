#!/usr/bin/env python
"""
Headless file writers, use Twisted instead of the Piety scheduler.
Here we still use the Piety Task class and schedule data structure
 but we use Twisted to capture events and dispatch tasks.
Here follows the header for the embedded script that uses the Piety scheduler,
 it is still mostly correct if you substitute 'Twisted' for some 'Piety':
------
Start a Piety session running two concurrent file writer tasks, but
without an interactive interpreter.  Shows that Piety can run in a
'headless' mode with no console, as is needed in some embedded
systems.

When you run this script, Piety schedules the tasks to write 10
messages to w0.txt and 5 messages to w1.txt, then Piety exits.  To
see the writers working, open a terminal window and type: tail -f
w0.txt.  In another terminal window: tail -f w1.txt.

To repeatedly schedule the tasks, start the command using python -i
embedded. When Piety exits, writing stops, and the Python prompt
appears, type main():

 $ python -i embedded.twisted
 ... w0 writes 10 messages, w1 writes five, then they stop ...
 >>> main()
 ... writers write, stop again ...

"""

from twisted.internet import reactor

import piety # we still use Piety Task class, schedule data structure etc.
from writer import Writer # applications

w0,w1 = Writer(fname='w0.txt'),Writer(fname='w1.txt')

# use this for t1.guard
def alternate():
    'Return True on every other timeout event.'
    return bool(piety.ievent[piety.timeout]%2)

# writer tasks assigned guard=(lambda:False) so they don't start running
t0 = piety.Task(handler=w0.write,event=piety.timeout,enabled=piety.true)
t1 = piety.Task(handler=w1.write,event=piety.timeout,enabled=alternate)

#
# Twisted - use this instead of the Piety event loop
#

class Timeout(object):

    def __init__(self):
        self.period = 1 # second, same as embedded script.
        self.nevents = 10 # same as embedded script

    def handler(self):
        if piety.ievent[piety.timeout] == self.nevents:
            reactor.stop()
        else:
            # handle scheduled timeout events
            if piety.timeout in piety.schedule:
                for t in piety.schedule[piety.timeout]:
                    if t.enabled():
                        t.handler()
            else:
                pass # if no timeout handler, just continue
            # count events and schedule next timeout
            piety.ievent[piety.timeout] += 1
            interval = self.period # if we got here, full interval has elapsed
            reactor.callLater(interval, self.handler)

reactor.callWhenRunning(Timeout().handler)  # should this go in main() - ?

def main():
    reactor.run()

if __name__ == '__main__':
    main()
