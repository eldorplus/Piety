
demo.py
=======

**[demo.py](demo.py)** demonstrates several features of the Piety system,
including concurrent tasks, a display editor, a windowing system,
and an enhanced shell.

**demo.py** uses the Piety scheduler to run the
[edsel](../editors/edsel) display editor as a task,
concurrently with two timestamp tasks.  Each timestamp task updates an
editor buffer.  You can see these buffers update in their windows as
you edit in another window or on the command line.

Here is a sample session that demonstrates this.  First, at the system
command line, change directory to the Piety scripts directory, then
type the command to set up the Python path to find all the Piety modules, 
then type the command to start the demo:

    $ cd ~/Piety/scripts
    $ . ../bin/asyncio_paths
    $ python3 -im demo

The *edsel* screen with one window appears, showing the *main* buffer
containing the line *This is the main buffer*.  At the bottom of the
screen is a two-line scrolling command entry region, where you type
commands at the *:* editor prompt.

Type commands at the *edsel* command prompt to create
two new windows that show timestamps updating, then traverse to
the original *main* window and edit.  The *o2* command splits the window,
*b ts1* makes *ts1* the current buffer (and displays it in the focus window),
and *o* moves the focus to the next window:

    :o2
    :b ts1
    . * ts1                 61  ts1
    :o2
    :b ts2
    . * ts2                105  ts2
    :o
    :o

Then, at the prompt, type the *edsel* *C* command to change to
display editing mode. (That's a capital *C*, it is case sensitive.)

    :C

The cursor moves into the *main* window.  Type and edit text
in the window in the usual way for [edsel](../editors/edsel).
Notice that the lines generated by the two timestamp
tasks keep appearing and
scrolling up in the *ts1* and *ts2* windows as you edit.

To exit display editing mode and return to the command prompt, type *^Z*.
(control-Z).

Some interesting commands to type at the *edsel* command prompt:

 - *h 12* - Enlarge the scrolling command region to 12 lines, so 
 you can observe multiple commands or multiline output.

 - *n* - List all the editor text buffers.

 - *b ts1* - In the focus window, display the buffer that contains the
 timeout messages from *ts1task*.  This window updates each time the
 task generates a new message, even when another window gets focus
 and updates as its text is edited.

The *edsel* display editor has the *[wyshka](../shells/wyshka.py)*
shell built-in, so you can use the Python command line without exiting
the editor, by prefixing each Python command at the editor command
prompt with an exclamation point, or by typing just an exclamation
point on the editor command line by itself to switch to a Python
command line.  The *wyshka* Python prompt has just two darts, *>>*,
to distinguish it from the standard Python prompt.  Exit *wyshka* and
return to the editor command line by typing just a colon at the *>>* prompt on
the Python command line.

Some interesting Python commands to try:

 - *piety.tasks()* - show information about tasks

 - *ts1task.enabled=piety.false* - disable *ts1task* so *ts1* buffer stops updating

 - *ts1task.enabled=piety.true* -  enable *ts1task* so *ts1* buffer resumes updating

 - *ts1task.enabled=alternate* - run *ts1task* handler on alternate timeout events

 - *piety.cycle.period=0.1* - cause *ts1* buffer to update ten times a second.  We hav

 - *piety.cycle.period=1.0* - cause *ts1* buffer to resume updating once a second

 - *edsel.ed.a('append line after dot')* - or any other call from the *ed* API.

With *piety.cycle.period=0.0001* -- 10,000 events/second -- we can type
comfortably in the *main* buffer, with no lost characters -- although 
the cursor blinks furiously.   This is on an
early 2011 MacBook Pro, 2.3 GHz Intel Core i5, 4 GB, OS X 10.11.6 El
Capitan, with CPython 3.9.  Even with period 0.000001 we can type with
no lost characters, the display is updating at a blur (but probably not
a million times a second).

### API and data structures ###

You can access the editor API from the Python prompt
by prefixing calls with *edsel.ed.* as in *edsel.ed.n()*, etc.

You can access the storage API and data structures by prefixing identifiers
and calls with *edsel.text.*, as in *edsel.text.buffers* etc.

You can access the display API and data structures by prefixing identifiers
and calls with *edsel.frame.*, as in *edsel.frame.windows* etc.

### Bugs ###

There is no graceful way to exit from a program that uses Piety
tasking.  In this demo, you can type Q at the editor command prompt to
exit the editor, but then there is no more command prompt, so you have
to type control-C (^C or C-c) to get back to the CPython prompt *>>>*,
then you can type *exit()* or control-D (^D or C-d) to exit.  Neither
of these works at the wyshka Python prompt *>>*.

Type C-c etc. in the same way to exit after a crash and traceback.

There is a problem when any program that uses multiple character
keycodes runs as a task under Piety.  In this demo, the problem appears
when using the display editor, or when editing the command line.

Only keystrokes that make single-character keycodes work correctly
each time.  That includes all the regular alphanumeric and symbol keys,
and also control characters formed by holding down the control key,
and then typing another key. For example, control-f to move the cursor
forward one character (also written ^F or C-f) work as intended.

Keystrokes that make multiple character keycodes have a delayed
effect.  They are only effective when you press the next key.  These
include keycodes formed by holding down the alt key, then typing another
key, for example alt-f to move the cursor forward one word (also
written M-f).  You must type M-f twice to get the cursor to advance by
one word, then the next keystroke, whatever it is, causes the cursor
to advance by a word again.  The arrow keys also exhibit the same
problem, because they also send multiple-character keycodes.

To run this demo wihout encountering this problem, use only control
key commands, not alt key commands or arrow keys.  For example, use
C-f and C-b to move the cursor forward and back one character at a
time, but not M-f and M-b to move the cursor forward and back a word
at a time.  Use C-p and C-n to move the cursor to the previous line or
the next line, but not the up- and down-arrow keys.

Revised Dec 2022
