#!/usr/bin/env python
"""
piety.twisted - Session + Job + CommandLine + pysh, ed, edd + Twisted scheduler

Uses Twisted as the non-blocking scheduler.
Much like piety script, except use commandline.CommandLine not command.Command

Use directions in piety script docstring, in particular use edc(...)
to start line editor and edd(...) for display editor.

BUT this only provides rudimentary inline editing: backspace and ^U
(kill whole line), no other control or arrow keys, no history.
Also, ^D does not exit from editors or shell - it just hangs.
"""

import sys # for sys.stdin

from twisted.internet import stdio, reactor
from twisted.protocols import basic

import piety # we still use Piety Task class, schedule data structure etc.
import session, job, commandline
import pysh, ed, edd as _edd # rename edd module so we can use edd as job name
from writer import Writer # applications

class Namespace(object): pass # another way to avoid name clashes
jobs = Namespace()

# Session, a terminal task
console = session.Session(name='console', event=sys.stdin)

# Python shell

def pysh_startup():
    pysh.pexit = False # enable pysh event loop, compare to Job stopped= below

# Name the command pyshc to avoid name clash with pysh module
# Remove trailing blank from prompt, raw_input adds its own trailing blank
pyshc = commandline.CommandLine(prompt='>> ', handler=pysh.mk_shell())

# Put pysh job in the jobs namespace to avoid name clash with pysh module
# stopped=... enables exit on exit() command or ^D
jobs.pysh = job.Job(session=console, application=pyshc, startup=pysh_startup, 
                    stopped=(lambda: pysh.pexit))

# line editor

# startup function handles optional filename argument and optional keyword arg.
def ed_startup(*filename, **options):
    if filename:
        ed.e(filename[0])
    if 'p' in options:
        edc.application.prompt = options['p'] 
    ed.quit = False # enable event loop, compare to Job( stopped=...) arg below

# Name the job edc to avoid name clash with ed module.
# Exit with q only, ^D exit is not enabled
edc = job.Job(session=console,
              application=commandline.CommandLine(prompt='', handler=ed.cmd),
              startup=ed_startup, stopped=(lambda: ed.quit))
              
# display editor

# startup function handles optional filename argument and optional keyword arg.
def edd_startup(*filename, **options):
    _edd.ed.quit = False # enable event loop, compare to Job( stopped=..) arg below
    if 'p' in options:
        edd.application.prompt = options['p'] #edd *not* _edd, Piety command object
    _edd.init_display(*filename, **options) # _ed.prompt is not used by Piety

# edd module was imported as _edd so we can call the job edd without name clash
edd = job.Job(session=console, 
              application=
              commandline.CommandLine(prompt='', handler=_edd.cmd),
              startup=edd_startup, 
              cleanup=_edd.restore_display)

# Enable exit with q, must use separate statement so application has a name
edd.stopped=(lambda: _edd.ed.quit)

# Make edd.main an alias for edd.__call__ so we can call edd.main(...) using
#  exactly the same syntax as when we import edd.py into Python without Piety
edd.main = edd.__call__

# File writer tasks

w0,w1 = Writer(fname='w0.txt'),Writer(fname='w1.txt')

# use this for t1.guard
def alternate():
    'Return True on every other timeout event.'
    return bool(piety.ievent[piety.timeout]%2)

# writer tasks assigned guard=(lambda:False) so they don't start running
t0 = piety.Task(handler=w0.write,event=piety.timeout,enabled=piety.true)
t1 = piety.Task(handler=w1.write,event=piety.timeout,enabled=alternate)

#
# Twisted, use this instead of the piety scheduler
#

class Console(basic.LineReceiver):
    'Twisted-style handler for input from stdin'

    from os import linesep as delimiter

    # Must provide methods with these names (override basic.Linereceiver)
    # FIXME - is this comment true?

    def connectionMade(self):
        jobs.pysh() # start the first Piety job, begin prompting
        sys.stdout.flush() # show initial prompt

    def lineReceived(self, line):
        console.handler(line) #  call Piety Session
        sys.stdout.flush() # show prompt
        piety.ievent[sys.stdin] += 1 # count events
        # interval = adjust_interval(t0, interval) # I think we don't need this
        if pysh.pexit:
            reactor.stop()

class Timeout(object):
    'Twisted-style timeout handler'

    def __init__(self):
        self.period = 1 # second, same as embedded script.
        self.nevents = 10 # same as embedded script

    def handler(self):
        if False and piety.ievent[piety.timeout] == self.nevents:
            # Now we use pysh.exit to stop, in Console lineReceived handler
            reactor.stop()
        else:
            # handle scheduled timeout events
            if piety.timeout in piety.schedule:
                for t in piety.schedule[piety.timeout]:
                    if t.enabled():
                        t.handler()
            else:
                pass # if no timeout handler, just continue
            # count events and schedule next timeout
            piety.ievent[piety.timeout] += 1
            interval = self.period # if we got here, full interval has elapsed
            reactor.callLater(interval, self.handler)

reactor.callWhenRunning(Timeout().handler)  # should this go in main() - ?

def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    in a non-blocking event loop scheduled by Twisted
    """
    stdio.StandardIO(Console())
    reactor.run()

if __name__ == '__main__':
    main()
