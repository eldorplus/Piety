#!/usr/bin/env python
"""
piety - Demonstrates how to run applications with the Piety scheduler.
 
This script runs the pysh shell and the ed and edd editors as jobs in
a terminal session under the Piety scheduler.  Also creates but does
not start two file writer tasks.  See comments below and inline for
more explanation.

This script start the pysh Python shell, with the prompt >>  (two not three >).
When editing the pysh command line, control keys and arrow keys work.
Exit the pysh shell with exit() or ^D.

To start ed line editor, use edc not ed: edc() or edc('README.md') etc., 
When editing the ed command line, control keys work but and arrow keys do not work.
Exit ed with the q command, ^D does not work.

To start edd display editor: edd() or edd('README.md') or main.edd('README.md') ...
When editing the edd command line, control keys and arrow keys work.
Exit edd with the q command or ^D.

To start w0 file writer task: w0.enabled=piety.true, to stop it again ...=...false
To see the file writing, tail -f w0.txt in another terminal window.  Ditto w1.

To see list of tasks including terminal session and two writers: piety.tasks()
"""

import sys
import piety, session, job, command, keyboard, key
import pysh, ed, edd as _edd # rename edd module so we can use edd as job name
import writer


class Namespace(object): pass # another way to avoid name clashes
jobs = Namespace()

# Session, a terminal task
console = session.Session(name='console', event=sys.stdin)

# Python shell

def pysh_startup():
    pysh.pexit = False # enable pysh event loop, compare to Job stopped= below

# Name the command pyshc to avoid name clash with pysh module
# Assign reader=key.Key that handles some multicharacter control sequences
pyshc = command.Command(prompt='>> ', reader=key.Key(),  handler=pysh.mk_shell())

# Put pysh job in the jobs namespace to avoid name clash with pysh module
# stopped=... enables exit on exit() command or ^D
jobs.pysh = job.Job(session=console, application=pyshc, startup=pysh_startup, 
                    stopped=(lambda: pysh.pexit or pyshc.command == keyboard.C_d), 
                    cleanup=piety.quit)

# line editor

# startup function handles optional filename argument and optional keyword arg.
def ed_startup(*filename, **options):
    if filename:
        ed.e(filename[0])
    if 'p' in options:
        edc.application.prompt = options['p'] 
    ed.quit = False # enable event loop, compare to Job( stopped=...) arg below

# Name the job edc to avoid name clash with ed module.
# Use default reader, not key.Key, so multicharacter control sequences
#  (such as keyboard arrow keys) will not work.
# Exit with q only, ^D exit is not enabled
edc = job.Job(session=console,
              application=command.Command(prompt='', handler=ed.cmd),
              startup=ed_startup, stopped=(lambda: ed.quit))
              
# display editor

# startup function handles optional filename argument and optional keyword arg.
def edd_startup(*filename, **options):
    _edd.ed.quit = False # enable event loop, compare to Job( stopped=..) arg below
    if 'p' in options:
        edd.application.prompt = options['p'] #edd *not* _edd, Piety command object
    _edd.init_display(*filename, **options) # _ed.prompt is not used by Piety

# edd module was imported as _edd so we can call the job edd without name clash
edd = job.Job(session=console, 
              application=
              command.Command(prompt='', reader=key.Key(), handler=_edd.cmd),
              startup=edd_startup, 
              cleanup=_edd.restore_display)

# Enable exit with q or ^D, must use separate statement so application has a name
edd.stopped=(lambda: _edd.ed.quit or edd.application.command == keyboard.C_d)

# Make edd.main an alias for edd.__call__ so we can call edd.main(...) using
#  exactly the same syntax as when we import edd.py into Python without Piety
edd.main = edd.__call__


# File writer tasks. These are not terminal jobs.

# Create but do not start file writer tasks.
# Set enabled=...false so these tasks do not run when piety scheduler starts.
w = writer.Writer(fname='w0.txt') # writes to w0.txt in current directory
w0 = piety.Task(handler=w.write,event=piety.timeout,enabled=piety.false)
w1 = piety.Task(name='w1', handler=writer.Writer(fname='w1.txt').write,
                event=piety.timeout,enabled=piety.false)


def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    """
    jobs.pysh() # start the first job, recall pysh is in jobs namespace
    piety.done = False # reset, might be resuming after pysh.pexit(), piety.quit()
                       # FIXME - doesn't pysh_startup do this also?
    piety.run() # start event loop, continue until pysh >> exit()

if __name__ == '__main__':
    main()
