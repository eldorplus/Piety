#!/usr/bin/env python
"""
piety - Run pysh shell, ed and edd editors in a Session under Piety scheduler
 Use command and key modules instead of Python raw_input to get command line.
 This script is named piety (with no file type) so no name clash with piety.py

To demonstrate the shell and editors:

  $ piety
 pysh shell, type any Python statement, exit() or Ctrl-D to exit
 >> console.run(edc)   # run the ed line editor
 ...
 q                     # exit ed, return to pysh Python shell
 >> console.run(eddc)  # run the edd display editor
 ...
 q
 >> exit()             # exit from pysh Python shell
 $                     # back to host shell

To exit, then resume the piety session in a single Python session use python -i :

 $ python -i piety
 ...
 >> exit()             # exit from pysh Python shell
 >>>                   # back to host Python shell
 >>> main()            # restart piety script
 >>                    # back to pysh Python shell
 ...

To create, start, pause, resume a Piety task from the shell:

 ...
 >> w0 = writer.Writer(fname='w0.txt')
 >> t0 = piety.Task(name='w0',handler=w0.write,event=piety.timeout,enabled=piety.true)
 ... in another terminal window, tail -f w0.txt shows writer is writing to w0.txt
 >> piety.tasks()
 ... shows console and writer tasks 
 >> t0.enabled = piety.false
 ... w0.txt stops growing
 >> t0.enabled = piety.true
 ... w0.txt resumes growing


This script demonstrates how a different keyboard reader can be
selected for each terminal job.  This script configures the shell and
display editor jobs using the input reader from the key module, so
these jobs can use some keys that send multi-character control
sequences (such the four keyboard arrow keys in the lower right corner
of the MacBook Pro keyboard).  The line editor is configured with the
default reader that just handles single-character keycodes, so it
cannot use those arrow keys, but it can use the alternatives ^F ^B ^N
^P which send single-character codes.
"""

import sys
import piety, session, job, command, key, pysh, ed, edd
import terminal # for main loop only

def pysh_startup():
    pysh.pexit = False # enable event loop, compare to Job( stop=...) arg below
    print "pysh shell, type any Python statement, exit() or Ctrl-D to exit"

# Python shell

pyshcc = command.Command(prompt='>> ', reader=key.Key(), 
                         handler=pysh.mk_shell())
pyshc = job.Job(application=pyshcc,
                startup=pysh_startup, 
                restart=pyshcc.restart,
                reader=pyshcc.reader, 
                replaced=(lambda: '.run(' in pyshcc.command),
                stopped=(lambda: pysh.pexit), 
                suspend=piety.quit)

# console session, a Piety task, initially runs Python shell
# Then use console to run other jobs from shell: console.run(edc) etc.
console = session.Session(name='console', event=sys.stdin, job=pyshc)

# line editor

def ed_startup():
    ed.quit = False # enable event loop, compare to Job( stop=...) arg below

edcc = command.Command(prompt='', reader=key.Key(), handler=ed.cmd)

edc = job.Job(application=edcc,
              startup=ed_startup, 
              restart=edcc.restart,
              reader=edcc.reader,
              replaced=(lambda: '.run(' in edcc.command),
              stopped=(lambda: ed.quit), 
              suspend=console.stop)

#alternatively we could use Command default terminal.getchar for reader
#alternatively we could check string rather than state variable
#edc.stop = (lambda: edc.command == 'q') # check command string not state variable
              
# display editor

def edd_startup():
    edd.ed.quit = False # enable event loop, compare to Job( stop=...) arg below
    edd.init_display()

eddcc = command.Command(prompt='', reader=key.Key(), handler=edd.cmd)

eddc = job.Job(application=eddcc,
               startup=edd_startup, 
               restart=eddcc.restart,
               reader=eddcc.reader,
               replaced=(lambda: '.run(' in eddcc.command),
               stopped=(lambda: edd.ed.quit), 
               cleanup=edd.restore_display,
               suspend=console.stop)

def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    """
    piety.done = False # reset, might be resuming after pysh.pexit(), piety.quit()
    console.foreground.restart()  # print prompt, set terminal char mode
    piety.run()  # start event loop, continue until pysh >> exit()

if __name__ == '__main__':
    main()
