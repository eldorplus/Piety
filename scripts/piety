#!/usr/bin/env python
"""
piety - Run pysh shell, ed and edd editors in a Session under Piety scheduler
 Use command and key modules instead of Python raw_input to get command line.
 This script is named piety (with no file type) so no name clash with piety.py

  $ piety
 pysh shell, type any Python statement, exit() or Ctrl-D to exit
 >> console.run(edc)   # run the ed line editor
 ...
 q                     # exit ed, return to pysh Python shell
 >> console.run(eddc)  # run the edd display editor
 ...
 q
 >> exit()             # exit from pysh Python shell
 >>>                   # Back to regular Python shell

"""

import sys
import piety, pysh, ed, edd, command, key, session
import terminal # for main loop only

def banner():
    print "pysh shell, type any Python statement, exit() or Ctrl-D to exit"

# Python shell
pyshc = command.Command(startup=banner, prompt='>> ', 
                        reader=key.Key(), handler=pysh.mk_shell(), 
                        stopcmd='exit()', suspend=piety.quit)

# console session, a Piety task, initially runs Python shell
# Then use console to run other commands from shell: console.run(edc) etc.
console = session.Session(name='console', event=sys.stdin, job=pyshc)

# line editor
edc = command.Command(prompt='', handler=ed.cmd, reader=key.Key(),
                      stopcmd='q', suspend=console.stop) 

# display editor
eddc = command.Command(prompt='', startup=edd.init_display, 
                       handler=edd.cmd, reader=key.Key(),
                       stopcmd='q', cleanup=edd.restore_display,
                       suspend=console.stop) 

def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    """
    piety.done = False   # enable event loop, previous exit may have set this True
    console.foreground()
    piety.run(nevents=0) # start event loop, continue until pysh exit()

if __name__ == '__main__':
    main()
