#!/usr/bin/env python
"""
piety - Demonstrates how to run applications with the Piety scheduler.
 
This script runs the pysh shell and the ed and edd editors as jobs in
a terminal session under the Piety scheduler.  Also creates but does
not start two file writer tasks.  See comments below and inline for
more explanation.

This script start the pysh Python shell, with the prompt >>  (two not three >).
When editing the pysh command line, control keys and arrow keys work.
Exit the pysh shell with exit() or ^D.

To start ed line editor, use edc not ed: edc() or edc('README.md') etc., 
When editing the ed command line, control keys work but and arrow keys do not work.
Exit ed with the q command, ^D does not work.

To start edd display editor: edd() or edd('README.md') or main.edd('README.md') ...
When editing the edd command line, control keys and arrow keys work.
Exit edd with the q command or ^D.

To start w0 file writer task: w0.enabled=piety.true, to stop it again ...=...false
To see the file writing, tail -f w0.txt in another terminal window.  Ditto w1.

To see list of tasks including terminal session and two writers: piety.tasks()
"""

import piety

# Writer tasks in writer_tasks module don't appear explicitly here - 
# they are referenced by the piety.schedule data structure used by piety.run
import writer_tasks

# Likewise, console jobs and session are referenced in console_tasks.jobs,
# and the session is also referenced in piety.schedule
# Must import identifiers used below and in pysh shell
# It seems pysh shell command line sees same scope as code in this module
from console_tasks import jobs, edc, edd

def main():
    """
    Run Python REPL and applications using pysh shell in a Session
    """
    jobs.pysh() # start the first job, recall pysh is in jobs namespace
    piety.done = False # reset, might be resuming after pysh.pexit(), piety.quit()
    piety.run() # start event loop, continue until pysh >> exit()

if __name__ == '__main__':
    main()
