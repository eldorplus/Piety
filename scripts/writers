#!/usr/bin/env python
"""
Start a Piety session running an interactive Python interpreter using the pysht
shell, also running two concurrent file writer tasks.

   $ python -i writers

If you exit from Piety or interrupt it, you will still be in Python
and can resume your Piety session with resume()

You can also start a standalone Piety session at the command line:

  $ writers

But here, if you exit or interrupt Piety you will also exit Python.  

Type a command to print the list of tasks:

 piety> piety.tasks()
  i  name  enabled              n  event            handler
  -  ----  -------              -  -----            -------
  0    t0  false               35  timeout 1.0 s    Writer.write   
  1    t1  alternate           35  timeout 1.0 s    Writer.write   
  2    t2  true                14  stdin            Console.getchar

To see the writers working, open a terminal window and
type:  tail -f w0.txt.  In another terminal window: tail -f w1.txt.
Initially, t1 is writing but t0 is not.  To start t0 writing:

 piety> t0.enabled=piety.true

"""

import sys
from writer import Writer

import terminal
import key
import line
import console
import pysht
import piety

w0,w1 = Writer(fname='w0.txt'),Writer(fname='w1.txt')

# use this for t1.guard
def alternate():
    """
    Returns True on every other timeout event
    """
    return bool(piety.ievent[piety.timeout]%2)

# writer tasks assigned guard=(lambda:False) so they don't start running
t0 = piety.Task(handler=w0.write,event=piety.timeout,enabled=piety.false)
t1 = piety.Task(handler=w1.write,event=piety.timeout,enabled=alternate)

t2 = piety.Task(name='pysh', event=piety.sys.stdin)
pysh = console.Console(prompt='>> ', command=pysht.mk_shell(), 
                       quit=piety.quit, optional_keymap=line.keymap)
k = key.Key(pysh.handle_key)
t2.handler = k.getchar

def main():
    pysh()
    console.Console.continues = True
    piety.done = False # reset, might be resuming after piety.quit() 
    piety.run(nevents=0) # loop forever, don't return
    terminal.restore()

if __name__ == '__main__':
    main()
