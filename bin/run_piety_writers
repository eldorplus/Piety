#!/usr/bin/env python
"""
Start a Piety session running in an interactive Python session

 python -i run_piety_writers

If you exit from Piety or interrupt it, you will still be in Python
and can resume your Piety session with resume()

You can also start a standalone Piety session at the command line:

 run_piety_writers

But here, if you exit or interrupt Piety you will also exit Python.  

"""

import sys
from writer import Writer

import console
import pysht
import piety

def run_piety_writers():
    """ 
    setup terminal and (re)start piety
    must be one command at the python prompt
    """
    piety.done = False # reset, might be resuming after piety.exit() 
    shell.restart() # clear buffer, print prompt
    piety.run(nevents=0) # loop forever, don't return

resume = run_piety_writers # but not 'r', single char commands reserved for ed

w0,w1 = Writer(fname='w0.txt'),Writer(fname='w1.txt')

# use this for t1.guard
def alternate():
    """
    Returns True on every other timeout event
    """
    return bool(piety.ievent[piety.timeout]%2)

# writer tasks assigned guard=(lambda:False) so they don't start running
t0 = piety.Task(handler=w0.write,event=piety.timeout,enabled=piety.false)
t1 = piety.Task(handler=w1.write,event=piety.timeout,enabled=alternate)

# default guard=(lambda:True) so start running immediately
shell = console.Console(command=pysht.mk_shell(), exiter=piety.exit)
t2 = piety.Task(handler=shell.getchar, event=piety.sys.stdin)

console.focus = shell

if __name__ == '__main__':
    run_piety_writers()
