#!/usr/bin/env python
"""
Run a Piety session including the edd display editor

  $ edd
>> piety.tasks()
... pysht, edd ...
>> edd()
... display appears ...
e README.md
1
q
>> ... any python statements ...
>> edd()
... edd resumes with display, buffer contents, other state as before ...
q
>> ^D
 $

This script shows how to ensure that console focus is switched between
the two console tasks: the shell pysht and the application edd, by using
console.Command.
"""

import sys

import console
import piety
import pysht

# use 'import foo as foo_m' so we can use foo as command name
import ed as ed_m 
import edd as edd_m

none = lambda: None

# pysht

# pysht_c is the console object whose command is the pysht shell
pysht_c = console.Console(prompt='>> ', command=pysht.mk_shell(), exiter=piety.exit)

# pysht_t is the task running the pysht_c console object
pysht_t= piety.Task(name='pysht', handler=pysht_c.getchar, event=piety.sys.stdin,
                    enabled=(lambda: console.focus == pysht_c))

# pysht is the callable to invoke to run the pysht shell in the real console
pysht = console.Command(pysht_c, pysht_c.restart, none, none, None)


# edd

edd_c = console.Console(prompt='', command=edd_m.cmd, exiter=piety.exit)
edd_t = piety.Task(name='edd', handler=edd_c.getchar, event=piety.sys.stdin,
                    enabled=(lambda: console.focus == edd_c))
edd = console.Command(edd_c, edd_m.init_display, ed_m.q, edd_m.restore_display,
                      pysht_c)


def run():
    'Assign focus to pysht shell, print shell prompt, (re)start scheduler.'
    pysht()
    piety.done = False # reset, might be resuming after piety.exit() 
    piety.run(nevents=0) # loop forever, don't return

if __name__ == '__main__':
    run()
