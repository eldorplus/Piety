#!/usr/bin/env python
"""
Start a Piety session *with the ed* editor running in an interactive
Python session

 python -i run_ed

From the Piety python prompt pysh>>  type ed() to enter ed command mode.
To return to pysh from ed command mode,  type q.

If you exit from pysh or interrupt it, you will still be in Python
and can resume your Piety session with resume()

You can also start a standalone Piety-with-ed session at the command line:

 run_ed_writers

But here, if you exit or interrupt Piety you will also exit Python.  

"""

import sys

import console
import pysht
import piety
import ed
from writer import Writer

# shell is the console object whose command is the pysht shell
shell = console.Console(prompt='pysh>> ', command=pysht.mk_shell(), 
                        exiter=piety.exit)
# pysh is the task running the shell console object
pysh = piety.Task(name='pysh', handler=shell.getchar, event=piety.sys.stdin,
                  enabled=(lambda: console.focus == shell))

# editor is the console object whose command is ed 
# must explicitly override default piety> prompt with empty prompt ''
# keep default exiter for emergency escape with ^D
editor = console.Console(prompt='',command=ed.ed_cmd,exiter=piety.exit)
# edit is the task running the editor console object
# don't call it ed because that's the name of the editor module
edit = piety.Task(name='edit', handler=editor.getchar, event=piety.sys.stdin,
                  enabled=(lambda: console.focus == editor))

# Must assign ed_q here because ed module contains ed function
#  ed module name will be reassigned to ed.ed function 
#  when we do pysh>> from ed import *
# Grab reference to ed module contents *before* we reassign ed
ed_q =  ed.q

def ed_revised():
    'revised ed command that changes focus to editor'
    console.change_focus(editor, editor.restart)

ed.ed = ed_revised # monkeypatch

def q_revised():
    'revised q command that returns focus to shell'
    ed_q()
    console.change_focus(shell, shell.restart)

ed.q = q_revised # monkeypatch

w0,w1 = Writer(fname='w0.txt'),Writer(fname='w1.txt')

# use this for t1.guard
def alternate():
    """
    Returns True on every other timeout event
    """
    return bool(piety.ievent[piety.timeout]%2)

# writer tasks assigned guard=(lambda:False) so they don't start running
w0 = piety.Task(name='w0',handler=w0.write,event=piety.timeout,
                enabled=piety.false)
w1 = piety.Task(name='w1',handler=w1.write,event=piety.timeout,
                enabled=alternate)

# start running with focus on piety python shell
console.focus = shell

# start or restart piety scheduler from python prompt
def run_piety():
    """ 
    setup terminal and (re)start piety
    one command at the python prompt
    """
    piety.done = False # reset, might be resuming after piety.exit() 
    shell.restart() # clear buffer, print prompt
    piety.run(nevents=0) # loop forever, don't return

# alias 
resume = run_piety # but not 'r', single-char commands reserved for ed

if __name__ == '__main__':
    run_piety()
